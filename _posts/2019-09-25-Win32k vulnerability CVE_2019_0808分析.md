
​    以前想分析内核相关的漏洞，存了几个cve待有时间搞一搞，前几个月看到这个，感觉挺适合我这入门选手，并且大佬还把poc也给放出来了，正好学习一下，直接看大佬的文章：https://blog.exodusintel.com/2019/05/17/windows-within-windows/，看到中间部分就懵逼了，什么Write Primitive，刚开始我还以为是：写权限，看安全客有个翻译版的，说是写入原语，一查字典，果然我错了~~。搞起来，重复造轮子吧，反正看到最后这种利用方式又是从入门到再见:)

#### 调试环境

本机：             windbg 10.0.14321.1024 x86

虚拟机：        win7 sp1 由于是更新到最新版，*被迫删了一些补丁*，见电脑里什么有个CVE-2018-8611补丁，直接                       						上了，运行exp蓝屏，就它了。

win32k.sys     6.1.7601.24313

MD5              : A13BD74DB27406E96337135FEBDD6D8F

Imagebase   : BF800000

直接用sp1，可能会出现不一致，因为没有win32k!MNGetpItemFromIndex这个函数，这函数代码直接在win32k!MNGetpItem内，但是也可以搞。



### 调试问题

   调试过程，比如断点win32k!xxxMNUpdateDraggingInfo的时候，会出现？？？ 数据无法访问，google说是win32k没什么加载之类的，不懂~~，

https://community.osr.com/discussion/165166#T2
When looking at session space you need to switch to a process from
the appropriate session. If you just want to disassemble win32k code,
any interactive process will do (e.g. explorer.exe):

!process 0 0 explorer.exe
.process /P

反正能用就行。

大便哥(windbg)用的不怎么熟悉，知道怎么断点就行： ba e 1 win32k!xxxMNUpdateDraggingInfo，用bp有时断不下来....



## 漏洞成因

​    这个咱就不详述了，一句话总结：

​    漏洞出现在UserMNDragOver函数内。hook事件函数，在里面放个拖曳动作；hook消息函数，检查WM_MN_FINDMENUWINDOWFROMPOINT消息，然后修改消息处理函数，在修改的消息处理函数内返回一个空的窗口句柄，(这个走位很骚...)。详细还是见数字报告那个图吧，一图见原因。

漏洞属性：NULL空指针引用

## 漏洞调试

​    算是第一次调内核漏洞，直接运行ze0r大神的exp，在windbg上就停在空指针触发的地方，这么容易就找到漏洞点，本以为挺简单的，可惜后来想错了，还是太“年轻”。中间经历过各种懵逼，甚至当初想着直接把NtUserMNDragOver函数给逆了，那问题就简单多了，一看代码量，还是算了。

略去中间的迷茫，思路理通后，开始点是这个：

![](/images/pic/0808(一)/start-0.png)

主要事情就在xxxMNUpdateDraggingInfo函数内，这个需要三个参数：

参数一:  gMenuState   就是全局的：_gMenuState  结构：win32k!tagMENUSTATE

参数二：窗口的指针  pMenuWnd；

参数三：查找的索引  index；

先锁定窗口到全局状态内，即把pMenuWnd写入到  gMenuState->uDraggingHitArea    eis+0x38

![](/images/pic/0808(一)/write_0x38_1.png)

把索引和窗口地址写入gMenuState后，通过索引查找假窗口菜单信息，当然假菜单什么都没，更别说什么菜单了：

![](/images/pic/0808(一)/mngetitem_2.png)

MNGetpItem两个参数，第一：tagPOPUPMENU,第二，索引。里面调用MNGetpItemFromIndex的时候，传入twin32k!tagPOPUPMENU->spMenu,这个值为0，即基指针为空，然后比较什么的之类取值就“锄禾日当午"了。

![3_MNGetpItemFromIndex](/images/pic/0808(一)/3_MNGetpItemFromIndex.png)

函数返回后，会再次调用MNGetpItemFromIndex，这次会构造值，用于之后的分支流程。

![4_tiaojian_jump](/images/pic/0808(一)/4_tiaojian_jump.png)

原文中说是构造一个特别特别大的值，我以为构造这么大值是为了表达：

 ((pMenuState->ptMouseLast.y - pMenuState->uDraggingHitArea->rcClient.top) + pItemFromIndex->yItem) > (pItem->yItem + SYSMET(CYDRAG)) 

但是呢，“jg”是个有符号操作符，构造特别大的话，像0xF0F0xxxx等，会造成特别小。其实，作者的目的应该就是这：构造一个特别大的负值，然后这样能保证之后的流程会设置 esi+0x40 这个位置的标记量。

![](/images/pic/0808(一)/5_jg.png)

其实在之后的调试中会发现，ebx，这个值特别小，我这一般是0x4，所以构造一个负值，这样会总是小于0x4：

![](/images/pic/0808(一)/8_nojg.png)

之后就是分支流程了，其实上面那个esi+0x40，会决定两条分支线，作者选择的是当前这个。

![](/images/pic/0808(一)/6_jmpjmp.png)

跳到最后，才是重点，这里函数存在Write Primitive。当把这个漏洞捋完，就知道这词表达的含义了。

xxxMNSetGapState 

参数一： gMenuState->uDraggingHitArea  传入的假窗口；

参数二： gMenuState->uDraggingIndex  查找的索引；

参数三： gMenuState->uDraggingFlags   标记量，就是 esi+0x40；

参数四： bool变量；

第一次调用，第三个参数为0，会退出来。第二次调用，开始小动作。

![](/images/pic/0808(一)/7_xxx.png)

函数内流程，首先会检测标记量：

![](/images/pic/0808(一)/9_flag.png)

进入关键的代码：

![](/images/pic/0808(一)/10_guanjian.png)

由于传入的标记量，曾经赋值过：0x1，索引，走的就是这个分支。从Null空间内取值，然后进行[eax+4], 0x40000000,当然也可以使用0x80000000进行赋值。按照作者的分支，其null空间的填值公式：

![](/images/pic/0808(一)/11_addressto.png)

这个公式看有点别扭，不是特别好理解，我按照我的想法给理顺一下：

假如填充的值为：x，  最后将要写入的地址为y， 这个地址可以计算出来：

ret + 4 = y 

ret = (index - 1) * 0x6c + x 

套进去： y - 4 = (index - 1) * 0x6c + x

​                x =  y - 4   -  (index  -1 ) *  0x6c 

其中 y  就是addressToWrite。primaryWindowAddress + 0x90   // primaryWindow.cbwndExtra 

index 就是pPopupAddressInCalculations， pPopupAddressInCalculations = wParam + 0x10。

下面是另一个分线，见网上大佬：CVE-2019-0808内核漏洞利用分析（ [kgsdy](https://xz.aliyun.com/t/5142)) 见他写的是另一个分支。

![](/images/pic/0808(一)/12_分支.png)



当时分析完，才知道，这个漏洞利用其实是先实现好，然后碰到存在null写入等漏洞，套上这个漏洞利用框架。待下一篇再详细分析，为什么写入那个值，之后，再发送消息，就可以执行shellcode了。

再说，又是一次从开始到再见的系列，原文中已经提到，最新版的win10，其中好几项：不能申请0x00地址，HMValidateHandle已经无法泄露信息等中间步骤已经不能用了，当然了，如果能用，或许这些大佬也不会放出来是吧(纯属瞎猜，因为之后存在一个恶意代码的漏洞和这个相似~~)。



ps：这已经是第三次撰写，写的都吐血了，十月一之前写的，放假后准备放到带有git的树莓派里，结果不知道为啥只有一半了，上周末，好不容易抽出点时间写完，保存后，再次打开又是半截，差一点把电脑给砸了，Typora也太不可靠了吧。

## 参考文章

[WINDOWS WITHIN WINDOWS – ESCAPING THE CHROME SANDBOX WITH A WIN32K NDAY](https://blog.exodusintel.com/2019/05/17/windows-within-windows/)( Grant Willcox )

[关于CVE-2019-0808内核提权漏洞的成因分析](http://blogs.360.cn/post/RootCause_CVE-2019-0808_CH)(成都应急响应中心 - 360核心安全)

[CVE-2019-0808利用里的几处数学问题](https://www.cnblogs.com/goabout2/p/11255693.html)(goabout2)

[CVE-2019-0808内核漏洞利用分析](https://xz.aliyun.com/t/5142)(kgsdy)

## 附带信息

当时的疑问和大佬的交流，大佬非常nice，还特别有耐心。非常感谢分享的poc或者exp，算是第一次完整的分析内核漏洞，还是很多东西需要学习。非常感谢~~

![1.png](/images/pic/0808(一)/twitter/1.png)

![](/images/pic/0808(一)/twitter/2.png)

![3.png](/images/pic/0808(一)/twitter/3.png)

![](/images/pic/0808(一)/twitter/5.png)
