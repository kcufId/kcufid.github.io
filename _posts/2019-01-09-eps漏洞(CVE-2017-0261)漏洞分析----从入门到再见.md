---
layout: post
title:  eps漏洞(CVE-2017-0261)漏洞分析----从入门到再见
tags: 漏洞分析
---


### 来由 

​        在去年(2018年)夏天某个燥热的晚上，空调屋里啃着西瓜打着坦克，突然一朋友帮忙让处理个样本，doc文件，坦克打的被虐的不轻，直接alt+f4游戏，样本搞起来，三下五除二把样本处理一下，eps文件内嵌的pe文件，简单的分析报告。分析完之后，虚拟机里运行doc竟然能运行起来，并且还释放文件了，然后就对这个漏洞刚兴趣了，一查去年的去年(2017年)firesys大神们有篇介绍报告([EPS Processing Zero-Days Exploited by Multiple Threat Actors](https://www.fireeye.com/blog/threat-research/2017/05/eps-processing-zero-days.html)),发现是doc是一样的，好吧。大神就是大神，一段伪代码，几张windbg图，清晰明了，我等小菜只能默默点X，自动动手搞起来，当时分析的也差不多了，中间有其他项目，也懒的搞，刚好趁着元旦放假，把打坦克的时间写个文档，努力收个尾，当时对uaf这个有点模糊，这次重新分析完成后，有了清晰的认识。当然，还重新看了一次PostScript语言，然后把这些知识点总结一下。

#### 目的

​        对PostScript脚本有个认识；

​        知道什么是UAF，也算是第一次详细分析uaf类型的漏洞，之前知道这个，看别人分析过，一直想找个机会深入理解一下。

# 入门知识

eps文件即PostScript语言编写的文件后缀，维基介绍：

![PostScript维基](/images/pic/pic_PostScript/PostScript维基.png)

对应eps文件介绍：

![eps介绍](/images/pic/pic_PostScript/eps介绍.png)

## PostScript介绍

​        PostScript是一种[图灵完全](https://zh.wikipedia.org/wiki/%E5%9B%BE%E7%81%B5%E5%AE%8C%E5%85%A8)的编程语言，通常PostScript程序不是人为生成的，而是由其他程序生成的。然而，仍然可以使用手工编制的PostScript程序生成图形或者进行计算。

​        PostScript是一种[基于堆栈](https://zh.wikipedia.org/w/index.php?title=%E5%9F%BA%E4%BA%8E%E5%A0%86%E6%A0%88&action=edit&redlink=1)的解释语言（例如[stack language](https://zh.wikipedia.org/w/index.php?title=Stack_language&action=edit&redlink=1)），它类似于[Forth语言](https://zh.wikipedia.org/wiki/Forth%E8%AF%AD%E8%A8%80)但是使用从[Lisp语言](https://zh.wikipedia.org/wiki/Lisp%E8%AF%AD%E8%A8%80)派生出的数据结构。这种语言的语法使用[逆波兰表示法](https://zh.wikipedia.org/wiki/Reverse_Polish_notation)，这就意味着不需要括号进行分割，但是因为需要记住堆栈结构，所以需要进行训练才能阅读这种程序。大部分*运算符*（其他程序中称为*函数*）从堆栈中读取变量，并且将运算结构放到堆栈中。如数字这样的*符号Literal*具有将它们自身副本放到堆栈的效果。

## PostScript语言的入门

​        分析这个漏洞，当然需要能看懂PostScript，我分析之前都没听说过还有这语言，这是分析过程中，总结的语言点：

首先是基于堆栈的，例如 ： 1 2 add     输入1 ，然后输入2 ，再输入add，则会把结果3 写入到最上面的堆栈上。

可以使用gscript 多测试：
![gscript](/images/pic/pic_PostScript/gscript.png)

​        语言内涉及的知识点：

数字：  正常字面数据，其他格式可以在#前写入对应格式数字，十六进制表示：16#123；

字符串： ()内表示字符串，<> 表示十六进制编码的数据；

变量名： /nmae  需要用"/" 在前面；

数组： []  中括号，内置的元素不限制类型：[123, /abc, (xyz)]；

函数： {}  大括号，脚本中还有末尾加个bind的，它把函数内的name都替换出来；

字典：<< >> ,配对输入。

脚本用到的一些操作命令，详细可见PLRM2.pdf手册,使用string举个例子，其他类似：




![string](/images/pic/pic_PostScript/string.png)

顺带介绍一下，微软word处理eps脚本时使用的引擎(EPSIMP32.FLT)，PostScirpt对象内的结构，

即在运行期间一个数据、字符串、数组等类型的结构体：                                                         一切对象皆为结构～～

```
// PostScript Object
struct PostScript object
{
    dword    type;
    dword    attr;
    dword    value1;
    dword    value2;    // if array, point to userdict where store the array object
}ps_obj;
// Struct A user-defined dictionary has the structure shown
struct
{
    dword    *pNext; // or null
    dword    dwIndex;
    ps_obj    key;
    ps_obj    value;
}kv;
```
​                                                                                   （来自firesys)



其中类型对应的数据如下(逆向内置的type_proc所得)：

```
0x0       	nulltype
0x3       	integertype
0x5       	realtype
0x8       	booleantype
0x10      	operatortype
0x20      	marktype
0x40      	savetype
0x300     	nametype
0x500     	stringtype
0x900     	filetype
0x30000   	arraytype          
0x0B0000 	packedarraytype
0x70000 	packedarraytype
0x110000  	dicttype
0x210000  	gstatetype
```

## 各类型对象不同点

对于简单对象，整数，value2，即为对应的值；

复合型对象：数组、字符串、字典等，value2，会指向一个索引指针，这个索引指针里的值指向一个复合型结构，详细如图：

![package_struct](/images/pic/pic_PostScript/package_struct.png)

以字符串结构举例：

复合结构类型： (大小:0x30)

```
+0x0  dword  free_proc   
+0x4  dword  ptr_basearray     //当前结构在指针数组中的位置；            
+0x8  dword              
+0xc  dword                	   //byte 会自动对齐
+0x10 dword              
+0x14 dword                    //初始化1  难道是true？           
+0x18 dword 
+0x1c dword              
+0x20 dword   p_base_class   
+0x24 dword   pp_struct        //保存的为指向0x28结构的指针的指针。     
+0x28 dword		               //保存的索引地址 
+0x2c dword   size             //字符串数组大小
```

字符串类型在+0x24 域保存的索引列表地址，这个指向一个最终的结构体，字符串类型的结构体如下：

大小：0x28

```
+0x0  dword   free_proc
+0x4  dword   ptr_basearray	  //即这个地址保存着当前0x28结构在指针数组中的位置，不是索引是地址；
+0x8  dword					  // 索引地址。
+0xc  dword
+0x10 dword
+0x14 dword    
+0x18 dword            	  	 //指向一个结构，基类地址+0x0B8的值。
+0x1c dword
+0x20 dword  ptr_object 	 //指向下面申请的内存，字符数据；
+0x24 dword  size      		 //申请的内存大小，字符串数组大小+1
```

数组这个结构大小会是：0x2c,和字符串的区别是：字符串+0x20指向字符数据；数组+0x28指向数组元素(元素由ps_obj组成)。

# 漏洞分析

​        铺设这么多，开始进入正题，这个eps漏洞是微软word在解析eps格式时，forall循环之前调用save--然后申请内存(创建字符串、数组)，在forall循环内，恢复(restore)之前save的数据，然后forall循环继续调用forall_proc，但是传入的参数指针依然指向的是save之后申请的内存数据块，也就是所谓的uaf漏洞。

这漏洞说简单就这么简单，看fireeye大神们的分析报告，还有几张windbg的图片，真心看不懂，只能拿起od开车了。。。(当然自己分析完之后就明白了那图片是什么意思了～)

刚开始接触这个漏洞的时候，直接od加上word的WINWORD.EXE，使用排除法一步一步找漏洞点,大神估计一条windbg命令就定位到了,谁让咱刚刚入门，就从小菜的方式开始，找到漏洞点位于模块：EPSIMP32.FLT，直接上ida看这个文件，大致过一下，是怎么处理命令的，不然在od里就是无头苍蝇，瞎几把转，恰巧找到了处理对应命令个模式：

![proc_table](/images/pic/pic_PostScript/proc_table.png)

​    EPSIMP32.FLT版本：2006.1200.4518.1014 (office2007,影响全版本，只是虚拟机里安装这个)

​    ida加载模块基地址：0x8F0000

可以从照片上看到，第一个偏移是命令字面值，下面是对应函数，可以找到forall处理函数：
![forall_proc](/images/pic/pic_PostScript/forall_proc.png)

froall处理array、string时的调用：![forall_proc_2](/images/pic/pic_PostScript/forall_proc_2.png)

这时就可以为所欲为的下断点调试了，在调试的过程还发现一个问题，如果直接使用od加载winword.exe，会变的各种卡，等待其他模块的加载等，多次调试后，萌生了为何不单独加载EPSIMP32.FLT的想法，然后简单逆了一下如何加载EPSIMP32.FLT的过程，winword加载epsimp32之前会加载MSO.DL，这个模块有一段根据文件名后缀判断是否是eps名称，其实还有jpg、wmf、tiff等其他文件，然后构造一个结构体，再调用EPSIMP32的初始函数，进行一些初始化，就调用其中引擎函数，执行eps文件，清楚了这个过程，自己写了个简单的加载模块，这样直接加载调试eps文件了，方便快捷：

LoadEps.exe  EPSIMP32.FLT  eps.conf  

放在同一目录即可，当然如果直接运行LoadEpx的话，会释放里面的恶意代码！！！

然后就是处理eps文件，还没说这个文件，直接7z解压doc文件，在解压目录内：word\media\image1.eps

打开后，愣眼了，仅三行，前两行还是注释～～，刚开始以为里面会带有混淆之类的，然而接触之后发现，没有无用的代码，整理一番这也是花时间最长的，把打坦克时间都花在这上面了。当然，如果是工作要求，可以直接搜索save，forall等找到关键代码，因为这玩意前奏真长，好多自定义函数：模拟add，sub，数组取值，hex转换等函数，大概就是这个样子：

![add_sub](/images/pic/pic_PostScript/add_sub.png)

开始正题，漏洞总共使用了三次：第一次检测当前环境是否32位还是64位，第二次构造特殊字符串，第三次构造特殊数组。

## 第一次触发漏洞

​        检测环境：![first_forall](/images/pic/pic_PostScript/first_forall.png)

l62 save 把状态保存到l62内，然后申请71个字节的字符串l63,调用forall：

string proc forall –                               execute proc for each element of string

l63内的字符，每放入一个，调用proc l61 间接调用l59,--> l56, restore恢复之前状态，申请的l63被free，这时候l63从第2字符开始就是野数据了，之后判断写入的数据是否存在l52字符串的长度，如果存在则会是64位；如果不存在，则是32位。(这个我没测，我这边环境只有32位的，之后的流程照32位走）

## 第二次触发漏洞

![second_forall](/images/pic/pic_PostScript/second_forall.png)

这个和第一次一样，不过开始精心构造数据了，并且forall是在一个循环内，直到结构达到满意程序才撤离，当然一次就行了～。

​      详细记录一下数据是如何uaf：

开始代码：![string_proc](/images/pic/pic_PostScript/string_proc.png)

string ps_obj 对象开始：



EBP-34   0012FDC0             00000500              string类型值  
EBP-30   0012FDC4             00000000  
EBP-2C   0012FDC8             00A3B5D8  
EBP-28   0012FDCC             00A2FACC               指向索引表                        



 00A2FACC 索引表地址，内容：

00A2FABC                                       60 33 A4 00  
00A2FACC   28 33 A4 00    

   00a43328 指向复合通用结构(0x30):

00A43328   DC 61 8F 00 CC FA A2 00 C8 13 A4 00 00 00 00 00  躠?铁???....  
00A43338   01 00 00 00 01 00 00 00 78 13 A4 00 00 00 00 00  ......x?....  
00A43348   60 3A 3F 00 C8 FA A2 00 00 00 00 00 47 00 00 00  `:?.鳃?....G...    

+0x24 保存的指针，00a2fac8,索引表地址，

00A2FAC8   60 33 A4 00 28 33 A4 00                          `3?(3???  
一般情况下，这个地址在上面结构地址前边：

   00a43360 指向字符串对象(0x28):

00A43360   4C 3F 8F 00 C8 FA A2 00 C4 13 A4 00 00 00 00 00  L??鳃???....  
00A43370   01 00 00 00 07 00 00 00 78 13 A4 00 00 00 00 00  ......x?....  
00A43380   90 33 A4 00 48 00 00 00        

+0x20 指向保存字符串的内容ansi,+0x24,字符大小，会比0x30结构内定义的大小+1字节：

00A43390   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................  
00A433A0   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................  
00A433B0   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................  
00A433C0   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................  
00A433D0   00 00 00 00 00 00 00 00   

这个时候，在forall执行执行之前，会从00a43390开始遍历字符，大小:0x47
当执行一次forall内的proc后，会再次在00a43390开始索引+1取值，然而proc的过程中
使用save即申请这个00a43390之前的内容，被restore后，也就是说00a43390地址就当没存在。
此时00a43390就是一个野地址。

上面即是第一次forall的过程，第二次调用的时候，申请的39 string，被重复利用的内存布局：



00EB4820    4C 3F 8F 00 40 E5 EA 00 00 00 00 00 00 00 00 00  L??@..........  
00EB4830    00 00 00 00 07 00 00 00 00 00 00 00 00 00 00 00  ...............  
00EB4840    00 18 EB 00 55 01 00 00           

刚好是字符串对象结构大小:0x28，同时写入的字符串也在里面，其中：+0x20 ==> 00eb1800
大小：0x0155

这就解开了为什么申请39(0x27)原因，因为字符串最终申请内存时，会自动+1，然后大小0x28，刚好一个字符串对象的结构体大小，然后引擎申请内存，刚好这一片0x28区域，就把字符串结构填到这，结果引擎中计了，这一片之后会变成野地址，这个过程很奇妙，这篇写完，再研究一下new的申请规律，为什么会申请到这。

之后还有处理写入字符串(l136)，把一些偏移补上，构造的字符串，完全模拟引擎的结构，只能叹为巧妙！！！

想感受一下的，可以用上面对象结构体，照着跟一下，这也是firesys报告中贴图的数据。

最终构造的数据：0x00eb1800  

![uaf_data](/images/pic/pic_PostScript/uaf_data.png)

这个数据块配合之后第三次触发漏洞，构造数据时使用的。

## 第三次触发漏洞

​        save---数组---restore，把字符串换成了数组：

![3_forall](/images/pic/pic_PostScript/3_forall.png)

大概过程：申请55(0x37)个元素的数组，每次push一个元素，调用forall_proc,在52个时候，restore，被uaf的数组和字符串的方式不一样，数组被uaf的是那个0x30大小的复合结构，上代码：

![array_forall](/images/pic/pic_PostScript/array_forall.png)

可以明显看到esi指向0x30的复合结构，这个值是一直不变的，当被uaf后，这块0x30被构造的数据l193覆盖：

![array_uaf](/images/pic/pic_PostScript/array_uaf.png)

为什么之前+0x24的0x12345678变成了第二次forall写入的数据偏移，因为在调用函数之前就写入的:)

覆盖之后，传入索引54(0x36)取最后一个值，当然，0x00eb1800指向的是一块构造的数据，可以照着类型结构跟一下，不要忘了加上0x360(0x36<<4)。获取的数组元素：
00EB1840  00 00 03 00 00 00 00 00 00 00 00 00 50 18 EB 00         ...........P?

(0x030000)数组类型，原谅我没找到一个好的修图工具，直接截图，加以修改：

![构造数据](/images/pic/pic_PostScript/构造数据.png)

数组共4个元素，其中第0个元素是字符串类型(l159),字符串开始地址：0x0，大小：0x7fffffff,这样可以使用此字符串读取任何值了，也就是在这个引擎空间(虚拟空间吧)，可以获得其他变量的地址，穿透当前虚拟空间读取真实的数据。

按照以前分析溢出漏洞的时候，都触发这么多次了，也该拿到eip干事情了，然而这才刚刚开始，不过也很简单了，看一下eps的艺术吧,写入负载的shellcode，这个shellcode是一个reload，一个dll，最终的恶意代码b12c.exe,当作字符串，写入到构造的数组，第3个索引内。

![write_file](/images/pic/pic_PostScript/write_file.png)

## 布局rop

​     在当前模块内查找特征符：

![rop](/images/pic/pic_PostScript/rop.png)

这个不再过多举例子了，其中64位会更复杂点。

当然那个构造的开始地址为0x0，大小0x7fffffff的字符串，发挥了巨大作用。

## 最后一个阶段

​        构造一个文件对象，因为在之后如何管控eip，是调用文件对象内的函数。

首先创建一个大小0x400的字符串，写入到构造数组第2索引内，因为这个构造的数组已经特别清晰，之前还是用硬偏移保存有索引2的所在地址，修改这个字符串ps_obj，改成file对象，即把第一个dword改成：0x900，填充这个文件对象，

![rop_start](/images/pic/pic_PostScript/rop_start.png)

构造rop地址，连上之前构造的rop，形成攻击链，光rop链都有3个类型，怕有些特征搜不到，使用另一种方式，只能说大神就是大神！

文件对象构造完成，调用closefile，掌管eip，感觉这也是uaf的关键点，因为就让你在此层写数据，读数据，没有执行点，那也白搭。看closefile代码就知道：

![file](/images/pic/pic_PostScript/file.png)

拿到构造的file对象，执行伪造的+0x8函数，掌管eip。

![eax_8](/images/pic/pic_PostScript/eax_8.png)

rop链就不贴图，交换堆栈，把堆栈改到eax那，下面的地址都是构造好的，然后ret，调用VirtualProtect,修改写入的shellcode数据块为可执行，然后返回到shellcode，开始干。



​    全文涉及的样本文档程序：<https://github.com/kcufId/eps-CVE-2017-0261>

# 总结

​        在分析的过程中，有的时候会想一想怎么修补这个漏洞，在forall第二个参数加个判断是否是函数类型，如果不是就可以不执行，因为漏洞就用这一点类型分不清，数组还是函数，结果就把数组当作函数用。这也是我在ghostscript上测试的时候，gs直接弹错误。但是考虑到，这个eps引擎那也就那么几种类型，如果再加一个定然代码量不少。写这篇文章找资料的时候，发现微软发公告，更新中默认把eps模块给关了～_~,这招真狠：

![eps_vulnerability](/images/pic/pic_PostScript/eps_vulnerability.png)

![esp_bye](/images/pic/pic_PostScript/esp_bye.png)

https://en.wikipedia.org/wiki/Encapsulated_PostScript#cite_note-3

https://support.microsoft.com/en-us/help/3178702/description-of-the-security-update-for-office-2016-april-11-2017



# 参考分析

1、[EPS Processing Zero-Days Exploited by Multiple Threat Actors](https://www.fireeye.com/blog/threat-research/2017/05/eps-processing-zero-days.html)

2、[CVE-2015-2545 Word 利用样本分析](https://paper.seebug.org/368/) 

3、[CVE-2015-2545: overview of current threats](https://securelist.com/cve-2015-2545-overview-of-current-threats/74828/)

4、[[翻译]EPS文件利用如何逃逸 EMET(CVE-2015-2545) —— 一次技术探索](https://bbs.pediy.com/thread-216045.htm)